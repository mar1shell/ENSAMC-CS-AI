# Sorting Algorithms

This folder contains implementations of various sorting algorithms, including:

- **Insertion Sort**: A simple sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.
- **Selection Sort**: An in-place comparison sorting algorithm. It has an O(n^2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort.
- **Quick Sort**: An efficient, in-place sorting algorithm that, on average, makes O(n log n) comparisons to sort n items. However, in the worst case, it can make O(n^2) comparisons.
- **Merge Sort**: An efficient, stable, comparison-based, divide and conquer sorting algorithm. Most implementations produce a stable sort, meaning that the order of equal elements is the same in the input and output.

Each algorithm has its own advantages and use cases, and the implementations provided here can be used to understand their mechanics and performance characteristics.